## 플러싱 메커니즘

- 플러싱은 메모리 내의 영속성 컨텍스트를 데이터베이스와 동기화하는 메커니즘으로, 트랜잭션 수명 동안 여러번 발생될 수 있으며 수동으로도 호출할 수 있다.




### 엄격한 플러시 작업 순서
- 플러시 시점까지 하이버네이트는 영속성 컨텍스트, 더 정확하게는 ActionQueue에서 엔티티의 수정을 버퍼링한다.
- 그리고 플러시 시점에 하이버네이트는 다음과 같이 일련의 작업을 엄격한 순서로 처리한다.

- OrphanRemovalAction
- EntityInsertAction & EntityIdentityInsertAction
- EntityUpdateAction
- CollectionRemoveAction
- CollectionUpdateAction
- CollectionRecreateAction
- EntityDeleteAction

>엔티티 처리에 해당하는 DML은 INSERT문으로 시작하고, UPDATE문을 다음으로, DELETE문을 마지막으로 처리한다.
>이 엄격한 순서는 데이터 액세스 레이어 부분 작업을 제어하고 제약 조건 위반 가능성을 최소화하도록 선택됐으므로
>데이터 액세스 레이어 코드를 작성하고 해석하는 방법에 주의를 기울여야 한다.
>명시적 플러시는 코드 스멜이며 일부의 경우에만 사용해야 한다.



### 데이터 질의어(DQL) 실행 전 플러시: SELECT 쿼리
- JPA과 하이버네이트 ORM은 직접 쓴 것을 읽는 일관성 (read-your-own-writes)을 유지하고자 쿼리 이전 플러시 (flush-before-query) 전략을 지원한다.
- 2차 캐시를 사용하지 않는 한 DQL SELECT 쿼리는 데이터베이스에 대해 실행되며 쿼리는 메모리 내의 변경 사항도 확인해야 한다.
- 따라서 사전 플러시가 필요하다.
- 즉 쿼리 실행 전 플러시가 트리거되지 않으면 쿼리가 쓰일 데이터를 읽지 않아 데이터 불일치가 발생할 수 있다.
- 그러나 일단 플러시가 트리거되면 플러시된 변경 사항이 쿼리와 현재 데이터베이스 트랜잭션에 적용된다.
- 해당 트랜잭션이 커밋된 후에만 다른 트랜잭션과 영속성 컨텍스트에 반영된다.


### 트랜잭션 커밋 전 플러시
- 현재 트랜잭션이 커밋된 후 영속성 컨텍스트는 클리어되고 닫힌다.
- 영속성 컨텍스트가 클리어되고 닫히면 엔티티의 메모리 내 변경 사항은 손실되는데, 이를 방지하고자 JPA와 하이버네이트 ORM은 트랜잭션이이 커밋되기 전에 플러시를 트리거한다.
- 이렇게 하면 엔티티의 메모리 내 변경 사항이 데이터 베이스에 전파되고 해당 변경 사항은 지속된다.



### 자동 플러시 모드
- 쿼리 실행 전과 트랜잭션 커밋 전의 플러시는 자동 플러시 모드를 통해 JPA와 하이버네이트 ORM에 의해 수행된다.

- 영속성 컨텍스트의 자동 플러시 모드는 다음과 같은 경우에 작동한다.
  - DQL SELECT, JPA JPQL 또는 하이버네이트 HQL 쿼리 실행 전
  - 네이티브 DQL SELECT 쿼리 실행 전
  - 트랜잭션 커밋 전