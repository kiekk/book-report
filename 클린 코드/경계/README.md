### 경계

#### 목차
- 외부 코드 사용하기
- 경계 살피고 익히기
- log4j 익히기
- 학습 테스트는 공짜 이상이다
- 아직 존재하지 않는 코드를 사용하기
- 깨끗한 경계

#### 북마크

```
인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다.
패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다.

...

반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
이런 긴장으로 인해 시스템 경계에서의 문제가 생길 요지가 많다.

-p144
```

#### 내 생각

이번 장에서의 예시인 Map의 경우 사용자가 clear() 메서드를 통해 Map 내용을 지울 권한이 있다거나,
Map에 여러 객체 유형을 저장할 수 있다는 위험이 있습니다.

객체 유형의 경우 java 5에서 제공되는 제네릭스를 사용하면 해결할 수는 있습니다.

```
// no generics
Map sensors = new HashMap();
Sensor s = (Sensor) sensors.get(sensorId);

// generics
Map<String, Sensor> sensors = new HashMap();
Sensor s = sensors.get(sensorId);
```

하지만 여전히 사용자에게 필요하지 않는 기능(clear()) 문제는 해결하지 못합니다.

만약 프로그램에서 Map<String, Sensors> 인스턴스를 여기저기로 넘긴다면,
Map 인터페이스가 변할 경우(물론 그럴 경우는 굉장히 드물지만),
수정할 코드가 상당히 많아지게 됩니다.

이 경우에는 Sensors 클래스를 만들어 내부에서 Map 인터페이스를 사용하도록 할 수 있습니다.

```java
public class Sensors {
    private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```

이렇게 작성하면 경계 인터페이스인 Map을 Sensors 안에 숨기기 때문에 Map 인터페이스가 변하더라도
나머지 프로그램에는 영향을 미치지 않습니다.
제네릭스를 사용하든 하진 않든 더 이상 문제가 안된다.
Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다.

또한 Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다.
그래서 코드는 이해하기 쉽지만 오용하기는 어렵다.
Sensors 클래스는 (나머지 프로그램이) 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

Map 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다.
Map을(혹은 유사한 경계 인터페이스를) 여기저기 넘기지 말라는 말이다.
Map과 같은 경계 인터페이스를 이용할 때는 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의합니다.
Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

위 내용은 책에서 설명한대로 꼭 Map만 해당하는 것이 아닌 외부에서 사용하는 API나 인터페이스에 대한 의존도나 결합도에 관한 내용같습니다.

외부 API, 인터페이스와 얼마나 결합되어 있는지 얼마나 의존하고 있는지에 따라 API, 인터페이스가 변경되었을 때 작성한 프로그램이 얼마나 변경되어야 하는지가 정해지기 때문에
의존도와 결합도를 낮춰 변경을 최소화 하게끔 코드를 작성하는 것이 좋다고 생각합니다.

그리고 외부 API, 인터페이스 말고도 직접 작성한 API나 인터페이스도 어디까지 기능을 제공할지 범위를 설정하는 것도 중요하다고 생각합니다.
인터페이스 내부에서만 사용하는 기능인데 불필요하게 외부에 제공하는 경우가 있는지, 또는 인터페이스가 책임과 역할에 맞지 않는 기능을 제공하고 있지는 않는지에 대해 계속 고민하는 것이 좋다고 생각합니다.

