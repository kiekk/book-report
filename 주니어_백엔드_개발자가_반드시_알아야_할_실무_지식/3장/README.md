## 3장 성능을 좌우하는 DB 설계와 쿼리

- DB 성능은 연동하는 모든 서버 성능에 영향을 준다.
- 하지만 DB 성능은 DB 자체가 문제인 상황보다 DB를 잘못 사용해서 발생한 문제가 더 많았다.


### 조회 트래픽을 고려한 인덱스 설계
- 일반적인 시스템에서는 조회 기능의 실행 비율이 높다.
- DB 테이블을 설계할 때는 조회 기능과 트래픽 규모를 고려해야 한다. 이를 고려하지 않으면 성능에 심각한 문제가 발생할 수 있다.


- 풀 스캔이 발생하지 않도록 하려면 조회 패턴을 기준으로 인덱스를 설계해야 한다.


### 단일 인덱스와 복합 인덱스

```sql
CREATE TABLE activityLog
(
    id integer(10) NOT NULL AUTO_INCREMENT,
    userId integer(10) NOT NULL,
    activityType varchar(20) NOT NULL,
    activityDate date NOT NULL,
    activityDatetime timestamp NOT NULL,
    memo varchar(200)
);


SELECT * FROM activityLog WHERE userId = 123 AND activityDate = '2024-07-31'
ORDER BY activityDatetime DESc
```

- 여기서 고민할 점은 userId 인덱스 생성 시 activityDate 컬럼을 포함할지 여부이다.
  - 단일 인덱스: userId 컬럼만 인덱스 생성
  - 복합 인덱스: userId, activityDate 컬럼을 모두 포함하는 인덱스 생성
- 사용자의 일별 활동 데이터를 기준으로 인덱스를 설계하면 된다.

```sql
SELECT activityDate, activityType, COUNT(activityType)
FROM activityLog
WHERE activityDate = '2024-07-28'
GROUP BY activityType;
```

- 여기서 고민할 점은 activityDate 인덱스 생성 시 activityType 컬럼을 포함할지 여부이다.
- activityType까지 인덱스에 추가하게 되면 위 쿼리는 커버링 인덱스만로 처리되기 때문에 데이터가 많을 경우 조회 시간을 단축할 수 있다.


### 선택도를 고려한 인덱스 컬럼 선택
- 인덱스를 생성할 때는 선택도(selectivity)를 고려해야 한다.
- 선택도는 인덱스에서 특정 컬럼의 고유한 값 비율을 나타낸다. (카디널리티와 유사한 개념)



### 커버링 인덱스 활용하기
- 커버링 인덱스는 특정 쿼리를 실행하는 데 필요한 컬럼을 모두 포함하는 인덱스를 말한다.


### 인덱스는 필요한 만큼만 만들기
- 인덱스를 관리하는 것도 비용이기 때문에 인덱스 생성에는 신중해야 한다.
- 테이블 작업 유형 빈도
  - `조회 > 추가, 수정, 삭제` 일 경우에는 인덱스가 효과적이겠지만 그게 아닐 경우 인덱스가 오히려 성능 저하에 요인이 될 수 있다.


## 몇 가지 조회 성능 개선 방법

### 미리 집계하기
- count나 sum과 같은 집계 쿼리를 조회 시점에 실행하면서 발생하는 성능 문제를 제거하는 방법은 간단하다.
- 집계 데이터를 미리 계산해서 별도 컬럼에 저장하면 된다.

```markdown
추가로 생각해볼 문제

1. 비정규화해도 괜찮나요?
성능을 위해서는 약간의 불일치를 감수하더라도 비정규화 하는 것이 좋을 수 있다.

2. 동시성 문제는 없나요?
동시성 문제는 비정규화로 인해 발생할 수 있다. 따라서 비정규화를 적용할 때는 동시성 문제를 고려해야 한다.
```


### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기
- offset을 사용하면 offset만큼 데이터를 스캔해야 하기 때문에 성능이 저하될 수 있다.
- 클러스터 인덱스인 id를 사용하여 zero-offset 방식으로 조회하는 것이 성능이 더 좋다.


### 조회 범위를 시간 기준으로 제한하기
- 조회 범위를 시간 기준으로 제한하면 성능이 개선될 수 있다.
- 또 다른 방법은 최신 데이터를 기준으로 조회하는 것이다.


### 전체 개수 세지 않기
- 데이터가 많아질수록 count 쿼리 실행 시간도 증가하는데, 그 이유는 조건에 해당하는 모든 테이블을 스캔해야 하기 때문이다.
- 커버링 인덱스를 사용하더라도 전체 인덱스를 스캔해야 하는데, 커버링 인덱스가 아닌 경우에는 실제 데이터를 전부 읽어야 한다.


### 오래된 데이터 삭제 및 분리 보관하기
- 데이터가 늘어날수록 쿼리 실행 시간은 증가한다.
- 데이터 증가 폭을 낮추는 방법 중 하나는 과거 데이터를 삭제하는 것이다.
- 과거 데이터를 삭제하면 데이터 개수를 일정하게 유지할 수 있어, 성능 또한 일정 수준으로 유지된다.


### DB 장비 확장하기
- 더 빠른 CPU로 교체하고 더 많은 CPU를 사용하여 메모리를 증설하면, 이 조치만으로도 성능은 눈에 띄게 향상된다.
- DB를 수평으로 확장하면 DB가 처리할 수 있는 트래픽을 늘릴 수 있다.
- 조회 트래픽 비중이 높은 서비스의 경우, 주 DB - 복제 DB (Primary-Replica) 구조를 사용해 처리량을 효과적으로 증가시킬 수 있다.
  - ex: CQRS


### 별도 캐시 서버 구성하기
- 꼭 대규모 트래픽이 아니더라도, 캐시 서버를 잘 활용하면 DB 확장 대비 적은 비용으로 더 많은 트래픽을 처리할 수 있다.
- 서버 개발자나 인프라 엔지니어 입장에서도, DB를 확장하는 것보다 레디스와 같은 캐시 서버를 구성하는 것이 상대적으로 부담이 적다.
- 물론 캐시를 도입하면 코드를 수정해야 한다.



## 알아두면 좋을 몇 가지 주의 사항

### 쿼리 타임아웃
- 쿼리 타임아웃은 DB 서버가 쿼리를 실행하는 데 걸리는 시간을 제한하는 설정이다.
- 쿼리 타임아웃을 설정하면 쿼리가 너무 오래 걸리는 경우 DB 서버가 쿼리를 중단하고 오류를 반환한다.
- 쿼리 타임아웃을 설정하면 DB 서버가 과부하에 걸리는 것을 방지할 수 있다.
- 쿼리 타임아웃을 설정할 때는 서비스의 특성을 고려해야 한다.
- 예를 들어, 블로그 글을 조회하는 기능은 타임아웃을 몇 초 이내로 짧게 설정해도 되지만
- 상품 결제 기능은 보다 긴 타임아웃이 필요하다. 결제 처리 중 타임아웃으로 에러가 발생하면 후속 처리와 데이터 정합성이 복잡해질 수 있기 때문이다.


### 상태 변경 기능은 복제 DB에서 조회하지 않기
- 주 DB - 복제 DB 구조를 사용할 때 변경은 주 DB를 사용하고 조회는 복제 DB를 사용한다.
- 그런데 이를 잘못 이해해 모든 SELECT 쿼리를 무조건 복제 DB로 보내는 경우가 있다.
- 이는 두 가지 측면에서 문제를 일으킬 수 있다.
- 주 DB와 복제 DB는 순간적으로 데이터가 일치하지 않을 수 있다. 주 DB에서 변경된 데이터는 다음 두 단계를 거쳐 복제 DB에 반영된다.
    - 네트워크를 통해 복제 DB에 전달
    - 복제 DB는 자체 데이터에 변경 내용을 반영
  - 이 과정에는 시간이 걸린다. 주 DB에서 복제 DB로의 데이터 복제에는 지연이 발생한다.
  - 이 지연 시간 만큼 주 DB와 복제 DB는 서로 다른 값을 갖게 된다.
- 트랜잭션 문제가 발생할 수 있다.


### 배치 쿼리 실행 시간 증가
- 한 번에 조회하고 집계하는 데이터가 많아질수록 일괄 처리용 쿼리의 실행 시간도 함께 증가한다.
- 집계 쿼리는 그 특성상 많은 양의 메모리를 사용하게 되며, 특정 임계점을 넘기면 실행 시간이 예측할 수 없을 만큼 길어질 수 있다.
- 이런 문제를 예방하려면 배치에서 사용하는 쿼리의 실행 시간을 지속적으로 추적해야 한다.


- 가장 빠른 해결책은 DB 장비의 사양을 높이는 것이다.
- 다른 대안으로는 커버링 인덱스 활용, 데이터를 일정 크기로 나눠 처리하는 방법이 있다.


### 타입이 다른 컬럼 조인 주의
- 조인하는 두 컬럼의 타입이 서로 다르기 때문에 인덱스를 활용하지 못할 수 있다.


### 테이블 변경은 신중하게
- 데이터가 많은 테이블에 새로운 컬럼을 추가하거나 기존 열거 타입 컬럼을 변경할 때는 매우 주의해야 한다.
- 무심코 컬럼을 변경했다가 서비스가 장시간 중단되는 상황이 발생할 수 있다.
- 주의해야 하는 이유는 DB의 테이블 변경 방식 때문이다.
  - MySQL의 경우 테이블을 변경할 때 새 테이블을 생성하고 원본 테이블의 데이터를 복사한 뒤,
  - 복사가 완료되면 새 테이블로 대체한다.
  - 이 과정에서는 UPDATE, INSERT, DELETE 같은 DML 작업을 허용하지 않기 때문에 복사 시간만큼 서비스가 멈춘다.


## 실패와 트랜잭션 고려하기
- 서버 초심자가 자주 놓치는 것 중 하나는 DB 트랜잭션을 고려하지 않는 것이다.
- 모든 코드가 항상 정상적으로 동작하는 것은 아니기 때문에 비정상 상황에서의 트랜잭션 처리를 반드시 고민해야 한다.

- 자주 발생하는 실수 중 하나는 트랜잭션 없이 여러 데이터를 수정하는 것이다.
- 외부 API 연동과 DB 작업이 섞이면 트랜잭션 처리가 복잡해진다.
- 외부 API 호출은 성공했지만 DB 작업이 실패하는 상황이 대표적이다.






