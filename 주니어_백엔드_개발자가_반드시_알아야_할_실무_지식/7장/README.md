## 7장 IO 병목, 어떻게 해결하지

### 네트워크 IO와 자원 효율
- 보통 입출력에 소요되는 시간은 코드를 실행하는 시간보다 훨씬 길다.
- 데이터 입출력이 완료될 때까지 스레드는 아무 작업도 하지 않고 입출력이 끝나기를 기다린다.
- 서버처럼 네트워크 연동이 많은 프로그램은 전체 실행 시간의 90% 이상을 입출력 대기에 사용하는 경우도 있다.


- 스레드가 대기하는 데 시간을 소용한다는 것은, 그 스레드를 실행하는 CPU도 아무것도 하지 않는 시간이 생긴다는 의미이다.

- 트래픽이 증가하면 다음 2가지 이유로 자원 효율이 떨어지게 된다.
  - IO 대기와 컨텍스트 스위칭에 따른 CPU 낭비
  - 요청마다 스레드를 할당함으로써 메모리 사용량이 높음

```markdown
성능을 높이겠다고 처음부터 비동기 IO로 개발하거나 가상 스레드를 적용하지는 말자.
실제로 IO 성능을 높여야 할 만큼 트래픽이 증가하고 있거나 예상되는 트래픽이 높은 경우에만 적용 여부를 고민하자.
```

### 가상 스레드로 자원 효율 높이기
- 가상 스레드와 고루틴은 경량(lightweight) 스레드라는 공통점을 갖는다.
- 경량 스레드는 OS가 관리하는 스레드가 아니라 JVM 같은 언어의 런타임이 관리하는 스레드다.
- 마치 OS가 CPU로 실행할 스레드를 스케줄링하듯, 언어 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.
- 가상 스레드를 경량 스레드라고 부르는 이유는 플랫폼 스레드보다 더 적은 자원을 사용하기 때문이다.


### 네트워크 IO와 가상 스레드
- 가상 스레드는 실행하는 과정에서 블로킹되면 플랫폼 스레드와 언마운트되고 실행이 멈춘다.
- 이때 언마운트된 플랫폼 스레드는 실행 대기 중인 다른 가상 스레드와 연결된 뒤 실행을 재개한다.


### 가상 스레드와 성능
- 네트워크 프로그래밍처럼 입출력이 주를 이루는 작업은 IO 중심 작업에 해당한다.
- 정렬처럼 계산이 주를 이루는 작업은 CPU 중심 작업에 해당한다.
- 가상 스레드는 IO 중심 작업일 때 효과가 있다.
- IO는 가상 스레드가 지원하는 블로킹 연산이므로, IO 중심 작업일 때 플랫폼 스레드가 CPU 낭비 없이 효율적으로 여러 가상 스레드를 실행할 수 있다.


### 논블로킹 IO로 성능 더 높이기
- 경량 스레드 자체도 메모리를 사용하고 스케줄링이 필요하다.
- 경량 스레드가 많아질수록 더 많은 메모리를 사용하고 스케줄링에 더 많은 시간을 사용하게 된다.

#### 논블로킹 IO 동작 개요
- 논블로킹 IO는 입출력이 끝날 때까지 스레드가 대기하지 않는다.
- 논블로킹 IO를 이용해서 구현한 서버는 블로킹 IO를 이용한 구현과 차이가 있다.
- 일반적으로 블로킹 IO로 구현한 서버는 커넥션별로 (또는 요청별로) 스레드를 할당한다.
- 반면 논블로킹 IO는 클라이언트 수에 상관없이 소수의 스레드를 사용한다.

### 리액터 패턴
- 리액터(reactor) 패턴은 논블로킹 IO를 이용해서 구현할 때 사용하는 패턴 중 하나다.
- 리액터 패턴은 동시에 들어오는 여러 이벤트를 처리하기 위한 이벤트 처리 방법이다.
- 리액터 패턴은 크게 리액터와 핸들러 두 요소로 구성된다.
  - 리액터는 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 알맞은 핸들러에 이벤트를 전달한다.
  - 핸들러는 이벤트를 수신하여 필요한 로직을 수행한다.


