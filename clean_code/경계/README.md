### 경계

#### 목차
- 외부 코드 사용하기
- 경계 살피고 익히기
- log4j 익히기
- 학습 테스트는 공짜 이상이다
- 아직 존재하지 않는 코드를 사용하기
- 깨끗한 경계

#### 북마크

```
인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다.
패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다.

...

반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
이런 긴장으로 인해 시스템 경계에서의 문제가 생길 요지가 많다.

-p144
```

```
외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다.
두 가지를 동시에 하기는 두 배나 어렵다.
다르게 접근하면 어떨까? 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신
먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까?
짐 뉴커크는 이를 학습 테스트라 부른다.

학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.
학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.

-p147
```

```
학습 테스트에 드는 비용은 없다.

...

오히려 필요한 지식만 확보하는 손쉬운 방법이다.
학습 테스트는 이해도를 높여주는 정확한 실험이다.
학습 테스트는 공짜 이상이다.
투자하는 노력보다 얻는 성과가 더 크다.
패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
학습 테스트는 패키지가 예상대로 도는지 검증한다.
일단 통합한 이후라고 하더라도 패키지가 우리 코드와 호환되리라는 보장은 없다.

...

학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.
이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.
그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.

-p150
```

```
통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.

...

외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는
인터페이스로 변환하자.
어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

-p152
```

#### 내 생각

#### 외부 코드

이번 장에서의 예시인 Map의 경우 사용자가 clear() 메서드를 통해 Map 내용을 지울 권한이 있다거나,
Map에 여러 객체 유형을 저장할 수 있다는 위험이 있습니다.

객체 유형의 경우 java 5에서 제공되는 제네릭스를 사용하면 해결할 수는 있습니다.

```
// no generics
Map sensors = new HashMap();
Sensor s = (Sensor) sensors.get(sensorId);

// generics
Map<String, Sensor> sensors = new HashMap();
Sensor s = sensors.get(sensorId);
```

하지만 여전히 사용자에게 필요하지 않는 기능(clear()) 문제는 해결하지 못합니다.

만약 프로그램에서 Map<String, Sensors> 인스턴스를 여기저기로 넘긴다면,
Map 인터페이스가 변할 경우(물론 그럴 경우는 굉장히 드물지만),
수정할 코드가 상당히 많아지게 됩니다.

이 경우에는 Sensors 클래스를 만들어 내부에서 Map 인터페이스를 사용하도록 할 수 있습니다.

```java
public class Sensors {
    private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```

이렇게 작성하면 경계 인터페이스인 Map을 Sensors 안에 숨기기 때문에 Map 인터페이스가 변하더라도
나머지 프로그램에는 영향을 미치지 않습니다.
제네릭스를 사용하든 하진 않든 더 이상 문제가 안된다.
Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다.

또한 Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다.
그래서 코드는 이해하기 쉽지만 오용하기는 어렵다.
Sensors 클래스는 (나머지 프로그램이) 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

Map 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다.
Map을(혹은 유사한 경계 인터페이스를) 여기저기 넘기지 말라는 말이다.
Map과 같은 경계 인터페이스를 이용할 때는 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의합니다.
Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

위 내용은 책에서 설명한대로 꼭 Map만 해당하는 것이 아닌 외부에서 사용하는 API나 인터페이스에 대한 의존도나 결합도에 관한 내용같습니다.

외부 API, 인터페이스와 얼마나 결합되어 있는지 얼마나 의존하고 있는지에 따라 API, 인터페이스가 변경되었을 때 작성한 프로그램이 얼마나 변경되어야 하는지가 정해지기 때문에
의존도와 결합도를 낮춰 변경을 최소화 하게끔 코드를 작성하는 것이 좋다고 생각합니다.

그리고 외부 API, 인터페이스 말고도 직접 작성한 API나 인터페이스도 어디까지 기능을 제공할지 범위를 설정하는 것도 중요하다고 생각합니다.
인터페이스 내부에서만 사용하는 기능인데 불필요하게 외부에 제공하는 경우가 있는지, 또는 인터페이스가 책임과 역할에 맞지 않는 기능을 제공하고 있지는 않는지에 대해 계속 고민하는 것이 좋다고 생각합니다.

#### 학습 테스트

```
학습 테스트는 말 그대로 테스트를 해가면서 특정 기술이나 개념을 학습하는 것이라고 생각하는데,
저자는 실제 테스트 케이스를 만들어 테스트를 해보면서 학습해야 버전간 이슈도 확인할 수 있고 테스트가 성공했다는 뜻으로
호환성을 보장할 수 있다고 합니다.

저도 이 부분에 어느 정도 동의하지만 반드시 테스트 코드를 작성해야 할 필요는 없다고 생각합니다.
기술에 따라 다르겠지만, Presentation 영역의 기술을 확인하기 위해서는 테스트 코드보다는 실제 코드를 실행하고 눈으로 확인하는 것이 더 효과적일 수 있습니다.
반면 기술의 동작 원리나 방식을 학습하기 위한 경우 테스트 보다는 디버깅을 통해 확인하는 것이 더 효과적일 수 있습니다.

따라서 제가 이해하고 내린 결론은, 기본적으로 기술이나 개념을 학습할 때 테스트 케이스, 그리고 테스트를 통해서 확인하는 것이
후에 버전 호환성에 대해서도 빠르게 파악할 수 있기 때문에 좋지만,
테스트 코드를 반드시 작성할 필요가 없는 상황에서는 직접 코드를 실행해 눈으로 확인하거나 디버깅을 통해 코드의 실행을 따라가보는 것도 좋다고 생각합니다. 
```